#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_demo.py

Один‑файловый «запускатель» для AlKAsH3D.
Создаёт простую сцену – вращающийся куб + пол – и отображает её
через Forward‑renderer (DX12‑бэкенд).  Если нативный DLL отсутствует,
бэкенд переходит в stub‑режим и скрипт всё‑равно завершится без падений.

Требования (см. requirements.txt.txt репозитория):
    pip install -r requirements.txt.txt
    pip install pillow   # для загрузки текстур (можно не ставить, если не используете)
"""

from __future__ import annotations

import numpy as np
import math

# ----------------------------------------------------------------------
# Импорт из установленного пакета
# ----------------------------------------------------------------------
from alkash3d import Engine, Window, Scene, Camera, DirectionalLight, \
    PointLight, SpotLight, Mesh, Node, Vec3, PBRMaterial, TextureManager, logger

# ----------------------------------------------------------------------
# Утилита – генератор куба (вершины, нормали, UV, индексы)
# ----------------------------------------------------------------------
def make_cube() -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Возвращает вершины, нормали, UV‑координаты и индексы для 24‑вершинного куба."""
    # позиции (по 4 вершины на каждую из 6 граней)
    verts = np.array(
        [
            # Front (+Z)
            [-0.5, -0.5, +0.5],
            [+0.5, -0.5, +0.5],
            [+0.5, +0.5, +0.5],
            [-0.5, +0.5, +0.5],
            # Back (‑Z)
            [+0.5, -0.5, -0.5],
            [-0.5, -0.5, -0.5],
            [-0.5, +0.5, -0.5],
            [+0.5, +0.5, -0.5],
            # Left (‑X)
            [-0.5, -0.5, -0.5],
            [-0.5, -0.5, +0.5],
            [-0.5, +0.5, +0.5],
            [-0.5, +0.5, -0.5],
            # Right (+X)
            [+0.5, -0.5, +0.5],
            [+0.5, -0.5, -0.5],
            [+0.5, +0.5, -0.5],
            [+0.5, +0.5, +0.5],
            # Top (+Y)
            [-0.5, +0.5, +0.5],
            [+0.5, +0.5, +0.5],
            [+0.5, +0.5, -0.5],
            [-0.5, +0.5, -0.5],
            # Bottom (‑Y)
            [-0.5, -0.5, -0.5],
            [+0.5, -0.5, -0.5],
            [+0.5, -0.5, +0.5],
            [-0.5, -0.5, +0.5],
        ],
        dtype=np.float32,
    )

    # нормали (по граням)
    norms = np.array(
        [
            # Front
            [0, 0, 1],
            [0, 0, 1],
            [0, 0, 1],
            [0, 0, 1],
            # Back
            [0, 0, -1],
            [0, 0, -1],
            [0, 0, -1],
            [0, 0, -1],
            # Left
            [-1, 0, 0],
            [-1, 0, 0],
            [-1, 0, 0],
            [-1, 0, 0],
            # Right
            [1, 0, 0],
            [1, 0, 0],
            [1, 0, 0],
            [1, 0, 0],
            # Top
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0],
            # Bottom
            [0, -1, 0],
            [0, -1, 0],
            [0, -1, 0],
            [0, -1, 0],
        ],
        dtype=np.float32,
    )

    # UV‑координаты (каждая грань – квадрат 0‑1)
    uv = np.array(
        [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, 1],
        ] * 6,
        dtype=np.float32,
    )

    # Индексы (по 2 треугольника на грань)
    inds = []
    for i in range(0, 24, 4):
        inds.extend([i, i + 1, i + 2, i, i + 2, i + 3])
    indices = np.array(inds, dtype=np.uint32)

    return verts, norms, uv, indices


# ----------------------------------------------------------------------
# Кастомный Mesh, который вращается каждый кадр
# ----------------------------------------------------------------------
class RotatingCube(Mesh):
    """
    Класс‑подкласс Mesh.  В методе on_update() меняет rotation.y,
    что заставляет объект крутиться вокруг оси Y.
    """
    def __init__(self, *args, rotation_speed: float = 30.0, **kwargs):
        super().__init__(*args, **kwargs)
        self.rotation_speed = rotation_speed  # градусы в секунду

    def on_update(self, dt: float) -> None:
        # Обновляем локальный угол Y (поворот в градусах)
        self.rotation.y = (self.rotation.y + self.rotation_speed * dt) % 360.0


# ----------------------------------------------------------------------
# Сборка сцены
# ----------------------------------------------------------------------
def build_scene() -> Scene:
    """Создаёт сцену: камера, освещение, вращающийся куб + пол."""
    scene = Scene()

    # --------------------------------------------------------------
    # Камера (fly‑through)
    # --------------------------------------------------------------
    cam = Camera(fov=70.0, near=0.1, far=200.0)
    cam.position = Vec3(0.0, 1.0, 3.0)          # стартовая позиция
    cam.rotation = Vec3(-15.0, 0.0, 0.0)        # слегка наклонена вниз
    scene.add_child(cam)

    # --------------------------------------------------------------
    # Освещение
    # --------------------------------------------------------------
    # Дневное солнце
    sun = DirectionalLight(
        direction=Vec3(-0.7, -1.0, -0.4),
        color=Vec3(1.0, 0.95, 0.9),
        intensity=3.5,
    )
    scene.add_child(sun)

    # Точечный свет‑лампа
    lamp = PointLight(
        position=Vec3(2.0, 2.0, 0.0),
        radius=6.0,
        color=Vec3(1.0, 0.7, 0.4),
        intensity=2.0,
    )
    scene.add_child(lamp)

    # --------------------------------------------------------------
    # Куб
    # --------------------------------------------------------------
    verts, norms, uvs, inds = make_cube()
    cube = RotatingCube(
        vertices=verts,
        normals=norms,
        texcoords=uvs,
        indices=inds,
        name="RotatingCube",
    )
    # PBR‑материал без текстур (чистый цвет)
    cube.material = PBRMaterial(
        albedo=(0.8, 0.2, 0.1, 1.0),   # ярко‑оранжево‑красный
        metallic=0.0,
        roughness=0.4,
        ao=1.0,
        emissive=(0.0, 0.0, 0.0),
    )
    scene.add_child(cube)

    # --------------------------------------------------------------
    # Пол (простой паркет из двух треугольников)
    # --------------------------------------------------------------
    floor_verts = np.array(
        [
            [-5.0, 0.0, -5.0],
            [+5.0, 0.0, -5.0],
            [+5.0, 0.0, +5.0],
            [-5.0, 0.0, +5.0],
        ],
        dtype=np.float32,
    )
    floor_norms = np.array([[0, 1, 0]] * 4, dtype=np.float32)
    floor_uvs = np.array([[0, 0], [1, 0], [1, 1], [0, 1]], dtype=np.float32)
    floor_inds = np.array([0, 1, 2, 0, 2, 3], dtype=np.uint32)

    floor = Mesh(
        vertices=floor_verts,
        normals=floor_norms,
        texcoords= floor_uvs,
        indices= floor_inds,
        name="Floor",
    )
    floor.material = PBRMaterial(
        albedo=(0.7, 0.7, 0.7, 1.0),
        metallic=0.0,
        roughness=0.9,
        ao=1.0,
    )
    scene.add_child(floor)

    # --------------------------------------------------------------
    # Ссылка на камеру (нужна Engine.scene.camera)
    # --------------------------------------------------------------
    scene.camera = cam
    return scene


# ----------------------------------------------------------------------
# Точка входа
# ----------------------------------------------------------------------
def main() -> None:
    """
    Создаёт окно, движок и запускает главный цикл.
    При отсутствии нативного DX12‑модуля будет использован stub‑режим,
    который всё‑равно позволяет увидеть, что скрипт «работает».
    """
    # --------------------------------------------------------------
    # 1️⃣ Окно
    # --------------------------------------------------------------
    win = Window(
        width=1280,
        height=720,
        title="AlKAsH3D – rotating cube demo",
    )

    # --------------------------------------------------------------
    # 2️⃣ Движок (по‑умолчанию forward‑renderer + DX12‑бэкенд)
    # --------------------------------------------------------------
    eng = Engine(
        width=win.width,
        height=win.height,
        title="AlKAsH3D – rotating cube demo",
        renderer="forward",      # попробуйте "deferred", "hybrid", "rtx"
        backend_name="dx12",    # "gl" пока не реализован, используем stub‑режим
    )

    # --------------------------------------------------------------
    # 3️⃣ Собираем сцену и подменяем её в движке
    # --------------------------------------------------------------
    eng.scene = build_scene()

    # --------------------------------------------------------------
    # 4️⃣ Запускаем главный цикл
    # --------------------------------------------------------------
    try:
        eng.run()
    except KeyboardInterrupt:
        # Позволяем выйти из программы клавишей Ctrl+C без страшных трасс
        logger.info("[run_demo] Пользователь прервал выполнение (Ctrl+C).")
    finally:
        # Очистка ресурсов (Engine.shutdown() будет вызван автоматически)
        eng.shutdown()


# ----------------------------------------------------------------------
# Позволяем запускать скрипт через `python run_demo.py`
# ----------------------------------------------------------------------
if __name__ == "__main__":
    main()
